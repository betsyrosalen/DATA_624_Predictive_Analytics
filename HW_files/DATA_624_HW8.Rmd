---
title: "DATA624 HW8"
subtitle: "Nonlinear Regression Models"
author: "Betsy Rosalen"
date: "4/26/2020"
output: 
    html_document: 
      code_folding: show
      css: ./style.css
      df_print: kable
      fig_caption: yes
      fig_width: 7
      fig_height: 4
      highlight: tango
      toc: yes
      toc_depth: 3
      toc_float:
        collapsed: no
        smooth_scroll: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
library(caret)
library(ggplot2)
library(kableExtra)
library(dplyr)

set.seed(123)
```

## Exercise 7.2

Friedman (1991)^[Friedman J (1991). “Multivariate Adaptive Regression Splines.” *The Annals of Statistics*, **19**(1), 1–141.] introduced several benchmark data sets created by simulation. One of these simulations used the following nonlinear equation to
create data:

$$
y = 10 sin(\pi x_1x_2) + 20(x_3 − 0.5)^2 + 10x_4 + 5x_5 + N(0, \sigma^2)
$$

where the $x$ values are random variables uniformly distributed between [0, 1]
(there are also 5 other non-informative variables also created in the simulation). The package mlbench contains a function called `mlbench.friedman1` that
simulates these data:

```{r}
library(mlbench)
set.seed(200)
trainingData <- mlbench.friedman1(200, sd = 1)
## We convert the 'x' data from a matrix to a data frame
## One reason is that this will give the columns names.
trainingData$x <- data.frame(trainingData$x)
## Look at the data using
featurePlot(trainingData$x, trainingData$y)
## or other methods.

## This creates a list with a vector 'y' and a matrix
## of predictors 'x'. Also simulate a large test set to
## estimate the true error rate with good precision:
testData <- mlbench.friedman1(5000, sd = 1)
testData$x <- data.frame(testData$x)
```

Tune several models on these data. For example:

```{r}
# library(caret)
knnModel <- train(x = trainingData$x, y = trainingData$y, method = "knn", 
                  preProcess = c("center", "scale"), tuneLength = 10)
knnModel
```

```{r}
knnPred <- predict(knnModel, newdata = testData$x)
## The function 'postResample' can be used to get the test set
## perforamnce values
knnPR <- postResample(pred = knnPred, obs = testData$y)
knnPR
```

Since KNN was already done for us let's try Neural Network, MARS, and SVM Models:

### Neural Network

```{r}
# library(nnet) # ecided to use caret instead
findCorrelation(cor(trainingData$x), cutoff = .75)

nnetGrid <- expand.grid(.decay = c(0, 0.01, .1),
                        .size = c(1:10),
                        .bag = FALSE)

ctrl <- trainControl(method = "cv")

avNNetModel <- train(trainingData$x, trainingData$y, 
                 method = "avNNet",
                 tuneGrid = nnetGrid,
                 trControl = ctrl,
                 preProcess = c("center", "scale"),
                 ## Specify how many models to average
                 # repeats = 5,
                 linout = TRUE,
                 ## Reduce the amount of printed output
                 trace = FALSE,
                 ## Expand the number of iterations to find parameter estimates..
                 maxit = 500,
                 ## and the number of parameters used by the model
                 MaxNWts = 10 * (ncol(trainingData$x) + 1) + 10 + 1)
avNNetModel
```

```{r}
avNNetPred <- predict(avNNetModel, newdata = testData$x)
avNNetPR <- postResample(pred = avNNetPred, obs = testData$y)
avNNetPR
```

### Multivariate Adaptive Regression Splines

```{r}
marsGrid <- expand.grid(.degree=1:2, .nprune=2:38)

marsModel <- train(x=trainingData$x, y=trainingData$y, 
                  method="earth",
                  # preProcess=c("center", "scale"), 
                  tuneGrid=marsGrid,
                  trControl = ctrl)
marsModel
```

```{r}
marsPred <- predict(marsModel, newdata=testData$x)
marsPR <- postResample(pred=marsPred, obs=testData$y)
marsPR
```

### Support Vector Machine

```{r}
svmRModel <- train(x=trainingData$x, y=trainingData$y, 
                  method="svmRadial", 
                  preProcess=c("center", "scale"), 
                  tuneLength=20)
svmRModel
```

```{r}
svmRPred <- predict(svmRModel, newdata=testData$x)
svmPR <- postResample(pred=svmRPred, obs=testData$y)
svmPR
```

### Model Comparison

Which models appear to give the best performance? 

```{r}
mods <- data.frame(rbind(knnPR, avNNetPR, marsPR, svmPR))
mods[order(mods$RMSE),]
```

The MARS model has the best performance as measured by all three metrics.

Does MARS select the informative predictors (those named `X1`–`X5`)?

```{r}
varImp(marsModel)
```

Yes, the MARS model did select the appropriate 5 predictors.

## Exercise 7.5

Exercise 6.3 describes data for a chemical manufacturing process. Use
the same data imputation, data splitting, and pre-processing steps as before
and train several nonlinear regression models.

```{r}
library(AppliedPredictiveModeling)
data(ChemicalManufacturingProcess)
```

```{r}
# missing <- data.frame(t(apply(is.na(ChemicalManufacturingProcess), 2, sum)))
# t(missing[,colSums(missing) > 0])
library(naniar) # for missing data viz
missingness <- ChemicalManufacturingProcess %>%
  miss_var_summary() 
kable(missingness %>% 
  filter(pct_miss > 0)) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

```{r}
imputer <- preProcess(ChemicalManufacturingProcess, method = "knnImpute")
CMP_imputed <- predict(imputer, ChemicalManufacturingProcess)
missing <- CMP_imputed %>%
  miss_var_summary() 
kable(missing %>% 
  filter(pct_miss > 0)) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

```{r}
near0 <- nearZeroVar(CMP_imputed)
cmp <- CMP_imputed[,-near0]
```

There are `r dim(cmp)[2]` predictors out of `r dim(CMP_imputed)[2]` left for modeling after removing variables with near zero variance.

```{r}
trainingRows <- createDataPartition(cmp$Yield, p = .80, list= FALSE)

train <- cmp[trainingRows, ]
trainx <- train[,-1]
trainy <- train$Yield
test <- cmp[-trainingRows, ]
testx <- test[,-1]
testy <- test$Yield
```

### K-Nearest Neighbors

```{r}
# library(caret)
knnModel <- train(x = trainx, y = trainy, method = "knn", 
                  preProcess = c("center", "scale"), tuneLength = 10)
knnModel
```

```{r}
knnPred <- predict(knnModel, newdata = testx)
## The function 'postResample' can be used to get the test set
## perforamnce values
knnPR <- postResample(pred = knnPred, obs = testy)
knnPR
```

### Neural Network

```{r}
# library(nnet) # ecided to use caret instead
findCorrelation(cor(trainx), cutoff = .75)

nnetGrid <- expand.grid(.decay = c(0, 0.01, .1),
                        .size = c(1:10),
                        .bag = FALSE)

ctrl <- trainControl(method = "cv")

avNNetModel <- train(trainx, trainy, 
                 method = "avNNet",
                 tuneGrid = nnetGrid,
                 trControl = ctrl,
                 preProcess = c("center", "scale"),
                 ## Specify how many models to average
                 # repeats = 5,
                 linout = TRUE,
                 ## Reduce the amount of printed output
                 trace = FALSE,
                 ## Expand the number of iterations to find parameter estimates..
                 maxit = 500,
                 ## and the number of parameters used by the model
                 MaxNWts = 10 * (ncol(trainx) + 1) + 10 + 1)
avNNetModel
```

```{r}
avNNetPred <- predict(avNNetModel, newdata = testx)
avNNetPR <- postResample(pred = avNNetPred, obs = testy)
avNNetPR
```

### Multivariate Adaptive Regression Splines

```{r}
marsGrid <- expand.grid(.degree=1:2, .nprune=2:38)

marsModel <- train(x=trainx, y=trainy, 
                  method="earth",
                  # preProcess=c("center", "scale"), 
                  tuneGrid=marsGrid,
                  trControl = ctrl)
marsModel
```

```{r}
marsPred <- predict(marsModel, newdata=testx)
marsPR <- postResample(pred=marsPred, obs=testy)
marsPR
```

### Support Vector Machine

```{r}
svmRModel <- train(x=trainx, y=trainy, 
                  method="svmRadial", 
                  preProcess=c("center", "scale"), 
                  tuneLength=20)
svmRModel
```

```{r}
svmRPred <- predict(svmRModel, newdata=testx)
svmPR <- postResample(pred=svmRPred, obs=testy)
svmPR
```

### Part (a) 

#### Model Comparison

Which models appear to give the best performance? 

```{r}
mods <- data.frame(rbind(knnPR, avNNetPR, marsPR, svmPR))
mods[order(mods$RMSE),]
```


### Part (b) 

Which predictors are most important in the optimal nonlinear regression model? Do either the biological or process variables dominate the
list? How do the top ten important predictors compare to the top ten
predictors from the optimal linear model?


### Part (c) 

Explore the relationships between the top predictors and the response for
the predictors that are unique to the optimal nonlinear regression model.
Do these plots reveal intuition about the biological or process predictors
and their relationship with yield?


### Footnotes